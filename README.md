# NextJS Introduction

- 기간: 22.07.16 ~ 22.07.20

- next.js, styled-jsx 개념, 동작원리에 대해 학습
- TMDB의 popular movie api 사용해서 화면에 뿌리기
- next.config.js 파일에서 rewrite 함수로 api key에 대한 정보를 masking함
- SSR을 사용해서 서버에서 모든 정보를 fetch한 후에 클라이언트에게 전달함으로써 유저가 로딩중 화면을 보지 않도록 함
- 중첩 라우팅, 다이나믹 라우팅을 nextjs에서 사용하는 법을 알기
- getServerSideProps함수를 사용해서 서버 사이드에서 router의 정보를 사용함, seo에 최적화하기 위함
- nextjs로 404 페이지를 쉽게 커스텀할 수 있음
<br/>

## framework vs library
**framework** 
- 만약 코드를 적절한 위치에 잘 적기만 한다면 개발자가 작성한 코드를 불러오는 것
    - **next.js**에서는 특정한 규칙을 따라야 한다!
    - 일련의 코드들을 추상화
    - 자동적으로 어떤 routing을 하지 않아도 pages 폴더에 넣어주면 된다
    - 약간의 집 같이 **내가 코드를 적절한 곳에 넣어놔야 함!!**
<br/>

**library**
- 개발자로서 라이브러리를 불러와서 무언가에 사용하는 것
    - react.js(cra)에서는 폴더구조를 내 마음대로 만들어서 관리할 수 있다= 많은 자유도가 있다!
        
        index.js와 app.js만 필수 존재, 
        `React.render()~~~` 
        
    - **우리가 원할 때 부르고 원할 때 사용하는** 라이브러리!!

## cra (CSR) vs next (SSR)
**CSR**
- UI가 렌더링되는 것을 브라우저가 전부 다 보는 것
- 유저가 보는 HTM이 소스코드 안에 들어있지 않음
- 브라우저는 오직 js와 `<div id="root"></div>` 만 가져옴(빈 화면이 보여짐)
- 모든 js와 react.js를 실행시키고  그후에서야 UI가 만들어진다 → Client-Side JS가 UI를 만드는 것임

**SSR**

- 페이지의 소스크드에 실제 HTML이 들어 있다.
- 어쩌면 API로부터 가져오는 데이터가 로딩되는 데에는 오랜 시간이 걸릴 수 있지만, 유저가 빈 화면만 보는 불편함은 겪진 않을 것이다

## **hydration**

- react.js를 프론트엔드 안에서 실행하는 것!!
- 페이지를 처음 열면 코드상 HTML이 있음. 그러고 나서 react.js가 클라이언트로 전송되었을 때, react.js 앱이 되는 것
1. nextjs는 reactjs를 백엔드에서 동작시켜서 **코드에 작성된 페이지를 미리 만듬** 
2. 그러면 렌더링이 됐을 때 **HTML이 되고** nextjs는 그 HTML을 페이지의 소스코드에 넣어둠  
3. 그러면 유저는 reactjs가 **로딩되지 않았더라도 콘텐츠를 볼 수 있게 됨** 
4. **reactjs가 로딩되었을 때** 이미 나와 있는 HTML, 존재하는 것들과 연결되서 일반적인 reactjs가 되는 것임
<br />

- 유저가 웹사이트에 들어가면 '초기 상태의 component로 된 미리 생성된 HTML 페이지'를 보게 되고 그리고 상호작용이 일어나면 reactjs는 그걸 받아서 동작하게 되는 것임!
- SEO 검색엔진에게도, 유저에게도 너무 좋아

## **styled-jsx (css-in-js)**

- 클래스이름은 페이지가 빌드될 때 무작위로 변경되기 때문에 코드상에서는 여러 페이지에서 중복된 클래스명을 사용할 수 있게 되는 것임 → 괴상한 클래스명!!
- nextjs에서 css는 styled-jsx를 추천한다! 모듈들이 모두 독립되어 있다 → 태그 네임으로 스타일을 지정할 수 있으므로 클래스명을 만들어야 하는 어려움, 번거로움을 해결가능!!
- scoped로 해당 컴포넌트에 한정되어 적용이 된다

[출처: 노마드 코딩 nextjs 강의]
